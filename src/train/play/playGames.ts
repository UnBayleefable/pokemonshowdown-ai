import * as path from "path";
import * as stream from "stream";
import {PRNGSeed} from "@pkmn/sim";
import ProgressBar from "progress";
import seedrandom from "seedrandom";
import {ExperienceConfig, GameConfig} from "../../config/types";
import {LogFunc, Logger} from "../../util/logging/Logger";
import {ModelWorker} from "../model/worker";
import {
    GamePool,
    GamePoolAgentConfig,
    GamePoolArgs,
    GamePoolResult,
} from "./pool/GamePool";
import {GamePoolStream} from "./pool/GamePoolStream";

/** Opponent data for {@link playGames}. */
export interface Opponent {
    /**
     * Name of the opponent for logging. Must be different than other opponents.
     */
    readonly name: string;
    /** Config for the BattleAgent. */
    readonly agentConfig: GamePoolAgentConfig;
    /** Number of games that this opponent will play. */
    readonly numGames: number;
}

/** Args for {@link playGames}. */
export interface PlayGamesArgs {
    /** Name of the current training run, under which to store logs. */
    readonly name: string;
    /** Current episode iteration of the training run. */
    readonly step: number;
    /** Used to request model ports for the game workers. */
    readonly models: ModelWorker;
    /** Config for the BattleAgent that will participate in each game. */
    readonly agentConfig: GamePoolAgentConfig;
    /** Opponents to play against. */
    readonly opponents: readonly Opponent[];
    /** Configuration for setting up the games. */
    readonly gameConfig: GameConfig;
    /** Logger object. */
    readonly logger: Logger;
    /** Path to the folder to store game logs in. Omit to not store logs. */
    readonly logPath?: string;
    /**
     * Configuration to process any Experiences that get generated by agents. If
     * omitted, experience is discarded.
     */
    readonly experienceConfig?: ExperienceConfig;
    /**
     * Function that generates valid paths to files in which to store
     * TrainingExamples (processed from game experience) as TFRecords. If not
     * specified, any experiences will be discarded.
     */
    readonly getExpPath?: () => Promise<string>;
    /** Whether to log win/loss/tie metrics to Tensorboard. */
    readonly logWlt?: boolean;
    /** Random seed generators. */
    readonly seed?: PlayGamesSeedRandomArgs;
}

/** Random number generators used by the game and policy. */
export interface PlayGamesSeedRandomArgs {
    /** Random seed generator for the battle PRNGs. */
    readonly battle?: () => string;
    /** Random seed generator for the random team PRNGs. */
    readonly team?: () => string;
    /** Random seed generator for the random exploration policy. */
    readonly explore?: () => string;
}

/**
 * Manages the playing of multiple games in parallel.
 *
 * @returns The number of TrainingExamples that were generated, if any.
 */
export async function playGames({
    name,
    step,
    models,
    agentConfig,
    opponents,
    gameConfig: {numThreads, maxTurns},
    logger,
    logPath,
    experienceConfig,
    getExpPath,
    logWlt,
    seed,
}: PlayGamesArgs): Promise<number> {
    const battleRandom = seed?.battle
        ? seedrandom.alea(seed.battle())
        : undefined;
    const teamRandom = seed?.team ? seedrandom.alea(seed.team()) : undefined;

    let numExamples = 0;
    for (const opponent of opponents) {
        const innerLog = logger.addPrefix(`Versus ${opponent.name}: `);

        const prefixWidth = innerLog.prefix.length;
        const postfixWidth =
            " wlt=--".length + 3 * Math.ceil(Math.log10(opponent.numGames));
        const padding = 2;
        const barWidth =
            (process.stderr.columns || 80) -
            prefixWidth -
            postfixWidth -
            padding;
        const progress = new ProgressBar(`${innerLog.prefix}:bar wlt=:wlt`, {
            total: opponent.numGames,
            head: ">",
            clear: true,
            width: barWidth,
        });
        progress.render({wlt: "0-0-0"});
        const progressLogFunc: LogFunc = msg => progress.interrupt(msg);
        const progressLog = new Logger(
            progressLogFunc,
            progressLogFunc,
            innerLog.prefix,
            innerLog.postfix,
        );

        // Iterator-like stream for piping GamePoolArgs to the GamePool stream.
        const poolArgs = stream.Readable.from(
            (function* generateArgs() {
                for (let i = 0; i < opponent.numGames; ++i) {
                    const gameLogPath =
                        logPath &&
                        path.join(logPath, `${opponent.name}/game-${i + 1}`);
                    const args: GamePoolArgs = {
                        id: i + 1,
                        agents: [
                            generateSeeds(
                                agentConfig,
                                seed?.explore,
                                teamRandom,
                            ),
                            generateSeeds(
                                opponent.agentConfig,
                                seed?.explore,
                                teamRandom,
                            ),
                        ],
                        models,
                        play: {
                            ...(maxTurns !== undefined && {maxTurns}),
                            ...(gameLogPath !== undefined && {
                                logPath: gameLogPath,
                            }),
                            seed: generatePrngSeed(battleRandom),
                            experienceConfig,
                        },
                    };
                    yield args;
                }
            })(),
            {objectMode: true},
        );

        // Stream for summarizing the game results.
        let wins = 0;
        let losses = 0;
        let ties = 0;
        const processResults = new stream.Writable({
            objectMode: true,
            write(result: GamePoolResult, encoding, callback): void {
                if (result.err) {
                    progressLog.error(
                        `Game ${result.id} threw an error: ` +
                            `${result.err.stack ?? result.err.toString()}`,
                    );
                }

                if (result.numExamples) {
                    numExamples += result.numExamples;
                }

                if (result.winner === 0) {
                    ++wins;
                } else if (result.winner === 1) {
                    ++losses;
                } else {
                    ++ties;
                }

                progress.tick({wlt: `${wins}-${losses}-${ties}`});

                callback();
            },
        });

        // TODO: Move pool outside loop for reuse?
        const pool = new GamePool(numThreads, getExpPath);
        try {
            await stream.promises.pipeline(
                poolArgs,
                new GamePoolStream(pool),
                processResults,
            );
        } finally {
            await pool.close();
        }

        progress.terminate();
        innerLog.debug(`Record: ${wins}-${losses}-${ties}`);

        if (logWlt) {
            await models.log(name, step, {
                [`eval/vs_${opponent.name}/win_ratio`]:
                    wins / opponent.numGames,
                [`eval/vs_${opponent.name}/loss_ratio`]:
                    losses / opponent.numGames,
                [`eval/vs_${opponent.name}/tie_ratio`]:
                    ties / opponent.numGames,
            });
        }
    }

    return numExamples;
}

/** Makes sure random team and exploration seeds are different between games. */
function generateSeeds(
    config: GamePoolAgentConfig,
    exploreSeedRandom?: () => string,
    teamRandom?: () => number,
): GamePoolAgentConfig {
    return {
        ...config,
        exploit:
            config.exploit.type === "random" && exploreSeedRandom
                ? {type: "random", seed: exploreSeedRandom()}
                : config.exploit,
        ...(config.explore &&
            exploreSeedRandom && {
                explore: {...config.explore, seed: exploreSeedRandom()},
            }),
        seed: generatePrngSeed(teamRandom),
    };
}

/** Same as `PRNG.generateSeed()` but with controled random. */
function generatePrngSeed(random = Math.random): PRNGSeed {
    // 64-bit big-endian [high -> low] integer, where each element is 16 bits.
    return Array.from({length: 4}, () =>
        Math.floor(random() * 0x10000),
    ) as PRNGSeed;
}
